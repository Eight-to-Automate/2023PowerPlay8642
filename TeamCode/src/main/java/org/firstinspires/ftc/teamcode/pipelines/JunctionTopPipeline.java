package org.firstinspires.ftc.teamcode.pipelines;

import static org.opencv.imgproc.Imgproc.findContours;

import com.vuforia.ar.pl.SystemTools;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import org.opencv.core.*;
import org.opencv.features2d.SimpleBlobDetector;
import org.opencv.imgproc.*;
import org.openftc.easyopencv.OpenCvPipeline;



/**
* JunctionTopPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class JunctionTopPipeline extends OpenCvPipeline {

	//Outputs
	private Mat blurOutput = new Mat();
	private Mat hslThresholdOutput = new Mat();
	private Mat cvErodeOutput = new Mat();
	private Mat maskOutput = new Mat();
	private Mat rgbThresholdOutput = new Mat();
	private MatOfKeyPoint findBlobsOutput = new MatOfKeyPoint();
	private ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();

	private int largestX, largestY;
	private double largestArea;

	// store the top and bottom of the cone, min is top and max is bottom
	double minY;
	double maxY;
	int height;

	Point centroid = new Point(-1, -1);
	Point lowerConeBound = new Point(-1, -1);
	Point upperConeBound = new Point(-1, -1);

	/*
	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}
	 */

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public Mat processFrame(Mat source0) {
			//File in = new File("PipelineLog.txt");

			//FileWriter w = new FileWriter(in);


			// Step Blur0:
			Mat blurInput = source0;
			BlurType blurType = BlurType.get("Gaussian Blur");
			double blurRadius = 7.207207207207208;
			blur(blurInput, blurType, blurRadius, blurOutput);


			// Step HSL_Threshold0:
				Mat hslThresholdInput = blurOutput;
				double[] hslThresholdHue = {33.99280575539569, 140.60606060606062};
				double[] hslThresholdSaturation = {14.022663959396748, 255.0};
				double[] hslThresholdLuminance = {0.0, 255.0};
				hslThreshold(hslThresholdInput, hslThresholdHue, hslThresholdSaturation, hslThresholdLuminance, hslThresholdOutput);


			// Step CV_erode0:
				Mat cvErodeSrc = hslThresholdOutput;
				Mat cvErodeKernel = new Mat();
				Point cvErodeAnchor = new Point(-1, -1);
				double cvErodeIterations = 0.0;
				int cvErodeBordertype = Core.BORDER_CONSTANT;
				Scalar cvErodeBordervalue = new Scalar(-1);
				cvErode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, cvErodeOutput);


				// Step Mask0:
				Mat maskInput = source0;
				Mat maskMask = cvErodeOutput;
				mask(maskInput, maskMask, maskOutput);



			// Step RGB_Threshold0:
				Mat rgbThresholdInput = maskOutput;
				double[] rgbThresholdRed = {0, 115.59705865131647};
				double[] rgbThresholdGreen = {0, 126.21212121212122};
				double[] rgbThresholdBlue = {0, 130.50505050505052};
				rgbThreshold(rgbThresholdInput, rgbThresholdRed, rgbThresholdGreen, rgbThresholdBlue, rgbThresholdOutput);

/*
			// Step Find_Blobs0:
				Mat findBlobsInput = rgbThresholdOutput;
				double findBlobsMinArea = 10.0;
				double[] findBlobsCircularity = {0.0, 1.0};
				boolean findBlobsDarkBlobs = false;
				findBlobs(findBlobsInput, findBlobsMinArea, findBlobsCircularity, findBlobsDarkBlobs, findBlobsOutput);


			KeyPoint[] keyArray = findBlobsOutput.toArray();

			double maxX = 0;
			double maxY = 0;
			double minX = 0;
			double minY = 0;

			for (KeyPoint i : keyArray) {
				double y = i.pt.y;
				double x = i.pt.x;

				if (x > maxX) {
					maxX = x;
				}

				if (x < minX) {
					minX = x;
				}

				if (y > maxY) {
					maxY = y;
				}

				if (y < minY) {
					minY = y;
				}

			}
			Point center = new Point((maxX + minX)/2,(maxY + minY)/2 );


			Imgproc.circle(findBlobsOutput, center,  50, new Scalar(255, 0, 0));
*/

		// Step Find_Contours0 (stage 3):
		Mat findContoursInput = rgbThresholdOutput;
		boolean findContoursExternalOnly = false;
		findContours(findContoursInput, findContoursExternalOnly, findContoursOutput);
		Mat findContoursOutputMat = source0.clone();
		for(int i = 0; i < findContoursOutput.size(); i++) {
			Imgproc.drawContours(findContoursOutputMat, findContoursOutput, i, new Scalar(255, 255, 255), 2);
		}

		// Finding largest contour (stage 4):
		Mat finalContourOutputMat = source0.clone();
		largestArea = -1;
		largestX = -1;
		largestY = -1;
		int largestContourIndex = -1;
		for(int i = 0; i < findContoursOutput.size(); i++) {
			MatOfPoint contour = findContoursOutput.get(i);
			double contourArea = Imgproc.contourArea(contour);
			if(contourArea < 50 && contourArea > largestArea) { // MIN or MAX contour area
				Moments p = Imgproc.moments(contour, false);

				int x = (int) (p.get_m10() / p.get_m00());
				int y = (int) (p.get_m01() / p.get_m00());

				largestContourIndex = i;
				largestX = x;
				largestY = y;
				largestArea = contourArea;
			}
		}

		if(largestContourIndex != -1)
			Imgproc.drawContours(finalContourOutputMat, findContoursOutput, largestContourIndex, new Scalar(255, 255, 255), 2);

		// isolate contour (stage 5)
		Mat contourIsolation = finalContourOutputMat;
		double[] hsvThresholdHue2 = {0, 0};
		double[] hsvThresholdSaturation2 = {0, 0};
		double[] hsvThresholdValue2 = {255, 255};
		hsvThreshold(finalContourOutputMat, hsvThresholdHue2, hsvThresholdSaturation2, hsvThresholdValue2, contourIsolation);

		// search for white pixels

		// establish significant points and lines for the camera stream
		Scalar white = new Scalar(0, 0, 0);
		Point centroid = new Point(largestX, largestY);
		Point lowerConeBound = new Point(largestX, maxY);
		Point upperConeBound = new Point(largestX, minY);

		Imgproc.line(finalContourOutputMat, lowerConeBound, upperConeBound, white);
		Imgproc.circle(finalContourOutputMat, centroid, 20, white, 20);

		return findContoursOutputMat;

	}

	/**
	 * This method is a generated getter for the output of a Blur.
	 * @return Mat output from Blur.
	 */
	public Mat blurOutput() {
		return blurOutput;
	}

	/**
	 * This method is a generated getter for the output of a HSL_Threshold.
	 * @return Mat output from HSL_Threshold.
	 */
	public Mat hslThresholdOutput() {
		return hslThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_erode.
	 * @return Mat output from CV_erode.
	 */
	public Mat cvErodeOutput() {
		return cvErodeOutput;
	}

	/**
	 * This method is a generated getter for the output of a Mask.
	 * @return Mat output from Mask.
	 */
	public Mat maskOutput() {
		return maskOutput;
	}

	/**
	 * This method is a generated getter for the output of a RGB_Threshold.
	 * @return Mat output from RGB_Threshold.
	 */
	public Mat rgbThresholdOutput() {
		return rgbThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a Find_Blobs.
	 * @return MatOfKeyPoint output from Find_Blobs.
	 */
	public MatOfKeyPoint findBlobsOutput() {
		return findBlobsOutput;
	}



	/**
	 * An indication of which type of filter to use for a blur.
	 * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
	 */
	enum BlurType{
		BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
			BILATERAL("Bilateral Filter");

		private final String label;

		BlurType(String label) {
			this.label = label;
		}

		public static BlurType get(String type) {
			if (BILATERAL.label.equals(type)) {
				return BILATERAL;
			}
			else if (GAUSSIAN.label.equals(type)) {
			return GAUSSIAN;
			}
			else if (MEDIAN.label.equals(type)) {
				return MEDIAN;
			}
			else {
				return BOX;
			}
		}

		@Override
		public String toString() {
			return this.label;
		}
	}

	/**
	 * Softens an image using one of several filters.
	 * @param input The image on which to perform the blur.
	 * @param type The blurType to perform.
	 * @param doubleRadius The radius for the blur.
	 * @param output The image in which to store the output.
	 */
	private void blur(Mat input, BlurType type, double doubleRadius,
		Mat output) {
		int radius = 7;
		int kernelSize;
		switch(type){
			case BOX:
				kernelSize = 2 * radius + 1;
				Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
				break;
			case GAUSSIAN:
				kernelSize = 6 * radius + 1;
				Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
				break;
			case MEDIAN:
				kernelSize = 2 * radius + 1;
				Imgproc.medianBlur(input, output, kernelSize);
				break;
			case BILATERAL:
				Imgproc.bilateralFilter(input, output, -1, radius, radius);
				break;
		}
	}

	/*
	  Segment an image based on hue, saturation, and luminance ranges.

	 @param input The image on which to perform the HSL threshold.
	  @param hue The min and max hue
	  @param sat The min and max saturation
	  @param lum The min and max luminance
	  @param output The image in which to store the output.
	 */
	private void hslThreshold(Mat input, double[] hue, double[] sat, double[] lum,
		Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_RGB2HLS);
		Core.inRange(out, new Scalar(hue[0], lum[0], sat[0]),
			new Scalar(hue[1], lum[1], sat[1]), out);
	}


	private void cvErode(Mat src, Mat kernel, Point anchor, double iterations,
		int borderType, Scalar borderValue, Mat dst) {
		if (kernel == null) {
			kernel = new Mat();
		}
		if (anchor == null) {
			anchor = new Point(-1,-1);
		}
		if (borderValue == null) {
			borderValue = new Scalar(-1);
		}
		Imgproc.erode(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
	}


	private void mask(Mat input, Mat mask, Mat output) {
		mask.convertTo(mask, CvType.CV_8UC4);
		Core.bitwise_xor(output, output, output);
		input.copyTo(output, mask);
	}

	/*
	  Segment an image based on color ranges.
	  @param input The image on which to perform the RGB threshold.
	  @param red The min and max red.
	  @param green The min and max green.
	  @param blue The min and max blue.
	  @param output The image in which to store the output.
	 */
	private void rgbThreshold(Mat input, double[] red, double[] green, double[] blue,
		Mat out) {
		//Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2RGB);
		Core.inRange(input, new Scalar(red[0], green[0], blue[0]),
			new Scalar(red[1], green[1], blue[1]), out);
	}


	private void findBlobs(Mat input, double minArea, double[] circularity,
		Boolean darkBlobs, MatOfKeyPoint blobList) {
		SimpleBlobDetector blobDet = SimpleBlobDetector.create();
		try {
			File tempFile = File.createTempFile("config", ".xml");

			StringBuilder config = new StringBuilder();

			config.append("<?xml version=\"1.0\"?>\n");
			config.append("<opencv_storage>\n");
			config.append("<thresholdStep>10.</thresholdStep>\n");
			config.append("<minThreshold>50.</minThreshold>\n");
			config.append("<maxThreshold>220.</maxThreshold>\n");
			config.append("<minRepeatability>2</minRepeatability>\n");
			config.append("<minDistBetweenBlobs>10.</minDistBetweenBlobs>\n");
			config.append("<filterByColor>1</filterByColor>\n");
			config.append("<blobColor>");
			config.append((darkBlobs ? 0 : 255));
			config.append("</blobColor>\n");
			config.append("<filterByArea>1</filterByArea>\n");
			config.append("<minArea>");
			config.append(minArea);
			config.append("</minArea>\n");
			config.append("<maxArea>");
			config.append(Integer.MAX_VALUE);
			config.append("</maxArea>\n");
			config.append("<filterByCircularity>1</filterByCircularity>\n");
			config.append("<minCircularity>");
			config.append(circularity[0]);
			config.append("</minCircularity>\n");
			config.append("<maxCircularity>");
			config.append(circularity[1]);
			config.append("</maxCircularity>\n");
			config.append("<filterByInertia>0</filterByInertia>\n");
			config.append("<filterByConvexity>0</filterByConvexity>\n");
			config.append("</opencv_storage>\n");
			FileWriter writer;
			writer = new FileWriter(tempFile, false);
			writer.write(config.toString());
			writer.close();
			blobDet.read(tempFile.getPath());
		} catch (Error e) {
			e.printStackTrace();
		} catch (IOException l) {
			l.printStackTrace();
		}

		blobDet.detect(input, blobList);
	}

	static boolean notZero(Mat m) {
		if (m.height() > 0 && m.width() > 0) {
			return true;
		} else {
			return false;
		}
	}

	private void findContours(Mat input, boolean externalOnly,
							  ArrayList<MatOfPoint> contours) {
		Mat hierarchy = new Mat();
		contours.clear();
		int mode;
		if (externalOnly) {
			mode = Imgproc.RETR_EXTERNAL;
		}
		else {
			mode = Imgproc.RETR_LIST;
		}
		int method = Imgproc.CHAIN_APPROX_NONE;
		Imgproc.findContours(input, contours, hierarchy, mode, method);
	}


	private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
							  Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
		Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
				new Scalar(hue[1], sat[1], val[1]), out);
	}


}

